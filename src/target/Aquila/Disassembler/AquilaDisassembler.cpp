#include "Aquila.h"
#include "AquilaSubtarget.h"
#include "llvm/MC/EDInstInfo.h"
#include "llvm/MC/MCDisassembler.h"
#include "llvm/MC/MCFixedLenDisassembler.h"
#include "llvm/Support/MemoryObject.h"
#include "llvm/Support/TargetRegistry.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Support/MathExtras.h"

#include "AquilaGenEDInfo.inc"

using namespace llvm;

typedef MCDisassembler::DecodeStatus DecodeStatus;

/// AquilaDisassembler - a disasembler class for Aquila32.
class AquilaDisassembler : public MCDisassembler {
	public:
		/// Constructor     - Initializes the disassembler.
		///
		AquilaDisassembler(const MCSubtargetInfo &STI)
			: MCDisassembler(STI) {}

		~AquilaDisassembler() {}

		/// getInstruction - See MCDisassembler.
		DecodeStatus getInstruction(MCInst &instr,
				uint64_t &size,
				const MemoryObject &region,
				uint64_t address,
				raw_ostream &vStream,
				raw_ostream &cStream) const;

		const EDInstInfo *getEDInfo() const;

	private:
		DecodeStatus readInstruction32(const MemoryObject &region,
				uint64_t address,
				uint64_t &size,
				uint32_t &insn) const;
};

const EDInstInfo *AquilaDisassembler::getEDInfo() const {
	return instInfoAquila;
}

// Decoder tables for Aquila register
static const unsigned CPURegsTable[] = {
	Aquila::ZERO, Aquila::V0,
	Aquila::A0, Aquila::A1, Aquila::A2, Aquila::A3,
	Aquila::T0, Aquila::T1, Aquila::T2, Aquila::T3,
	Aquila::S0, Aquila::S1, Aquila::S2, Aquila::S3,
	Aquila::SP, Aquila::RA
};

// Forward declare these because the autogenerated code will reference them.
// Definitions are further down.
// DecodeXXX関数はtablegenでDecoderMethodを指定した場合に
// decodeAquilaInstruction32()から参照される。

// tablegenで作成したCPURegs(RegisterClass)を表示する
static DecodeStatus DecodeCPURegsRegisterClass(MCInst &Inst,
		unsigned RegNo,
		uint64_t Address,
		const void *Decoder);
static DecodeStatus DecodeMem(MCInst &Inst,
		unsigned RegNo,
		uint64_t Address,
		const void *Decoder);

static DecodeStatus DecodeMoveTarget(MCInst &Inst,
		unsigned Insn,
		uint64_t Address,
		const void *Decoder);

static DecodeStatus DecodeCallTarget(MCInst &Inst,
		unsigned Insn,
		uint64_t Address,
		const void *Decoder);

static MCDisassembler *createAquilaDisassembler(
		const Target &T,
		const MCSubtargetInfo &STI) {
	return new AquilaDisassembler(STI);
}

extern "C" void LLVMInitializeAquilaDisassembler() {
	// Register the disassembler.
	TargetRegistry::RegisterMCDisassembler(TheAquilaTarget,
			createAquilaDisassembler);
}

#include "AquilaGenDisassemblerTables.inc"

/// readInstruction - read four bytes from the MemoryObject
/// and return 32 bit word sorted according to the given endianess
DecodeStatus AquilaDisassembler::
readInstruction32(const MemoryObject &region,
		uint64_t address,
		uint64_t &size,
		uint32_t &insn) const {
	uint8_t Bytes[4];

	// We want to read exactly 4 Bytes of data.
	if (region.readBytes(address, 4, (uint8_t*)Bytes, NULL) == -1) {
		size = 0;
		return MCDisassembler::Fail;
	}

	// Encoded as a small-endian 32-bit word in the stream.
	insn = (Bytes[3] <<  0) |
		(Bytes[2] <<  8) |
		(Bytes[1] << 16) |
		(Bytes[0] << 24);

	return MCDisassembler::Success;
}

DecodeStatus AquilaDisassembler::
getInstruction(MCInst &instr,
		uint64_t &Size,
		const MemoryObject &Region,
		uint64_t Address,
		raw_ostream &vStream,
		raw_ostream &cStream) const {
	uint32_t Insn;

	DecodeStatus Result = readInstruction32(Region, Address, Size,
			Insn);
	if (Result == MCDisassembler::Fail)
		return MCDisassembler::Fail;

	// Calling the auto-generated decoder function.
	Result = decodeInstruction(DecoderTableAquila32, 
			instr, Insn, Address, this, STI);
	if (Result != MCDisassembler::Fail) {
		Size = 4;
		return Result;
	}

	return MCDisassembler::Fail;
}

static DecodeStatus DecodeCPURegsRegisterClass(MCInst &Inst,
		unsigned RegNo,
		uint64_t Address,
		const void *Decoder) {
	if (RegNo > 31)
		return MCDisassembler::Fail;

	Inst.addOperand(MCOperand::CreateReg(CPURegsTable[RegNo]));
	return MCDisassembler::Success;
}

static DecodeStatus DecodeMem(MCInst &Inst,
		unsigned Insn,
		uint64_t Address,
		const void *Decoder) {
	int Offset = SignExtend32<16>(Insn & 0xffff);
	int Reg = (int)fieldFromInstruction(Insn, 16, 4);
	int Base = (int)fieldFromInstruction(Insn, 20, 4);

	Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Reg]));
	Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Base]));
	Inst.addOperand(MCOperand::CreateImm(Offset));

	return MCDisassembler::Success;
}

static DecodeStatus DecodeMoveTarget(MCInst &Inst,
		unsigned Insn,
		uint64_t Address,
		const void *Decoder) {
	int Offset = SignExtend32<20>(Insn & 0xfffff);
	int Reg = (int)fieldFromInstruction(Insn, 20, 4);

	Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Reg]));
	Inst.addOperand(MCOperand::CreateImm(Offset));

	return MCDisassembler::Success;
}

static DecodeStatus DecodeCallTarget(MCInst &Inst,
		unsigned Insn,
		uint64_t Address,
		const void *Decoder) {

	unsigned CallOffset = fieldFromInstruction(Insn, 0, 24) << 2;
	Inst.addOperand(MCOperand::CreateImm(CallOffset));
	return MCDisassembler::Success;
}
